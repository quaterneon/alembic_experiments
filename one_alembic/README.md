# Case
This case would be describing different services whose data are co-located in the same database, but isolated by giving 
each service its own schema.

In this situation there are several modules existing side-by-side. Each module contains it's own Metadata and table
definitions. Each metadata is tied to a different schema. There is a single alembic instance, but versions are located
with each service.

# Challenges encountered
Alembic by default has some interesting issues with autogenerating revisions within schemas. It tended to try to
re-create the whole table instead of adding/removing single elements. Adding the options to `env.py` to include schemas
allowed alembic to recognize changes to schemas, but it had the side effect of making the autogenerated revision see 
*all* schemas, even those for the other services. This resulted in the autogenerated revision for one service attempting
to delete all tables of a different service. Fortunately alembic supports an `include_object`, which allows for more
granular and programmatic control of what the autogeneration process decides to do with particular entities. In this 
case I added a case to the `include_object` to check the target schema if the item under consideration.

The second challenge was managing the alembic tree. There are many potential options and pitfalls, but in this pattern
the entire alembic tree interleaves revisions from different services. Managing the tree is greatly simplified, and 
could also potentially allow multiple heads should that be desirable or workable.

# How this pattern works
There is one alembic setup, i.e. a since `env.py`. This alembic setup is aware of the metadata of *every* service.
Each DB metadata is tied to a separate schema. There is a single `alembic_version` table for all services, which may contain
one or more values depending on whether multiple heads.

# What did I add to alembic to get this to work?
1. Tell alembic to look at all schemas when autogenerating the revisions (`include_schemas=True`)
2. `env.py` requires a list of all metadatas, meaning that all services need to be importable.

# Pros/Cons
* Pro: Revisions are still located with each service. 
* Pro: Managing the tree doesn't require anything complicated.
* Pro: Since there is only one alembic setup, you cannot encounter a misconfigured bad actor/service.
* Cons: Tree is not isolated per service.
* Cons: Autogeneration could potentially pick up changes in one or more services, meaning that revisions might not
be cleanly limited to one service. 