# Case
This case would be describing different services whose data are co-located in the same database, but isolated by giving 
each service its own schema.

In this situation there are several modules existing side-by-side. Each module contains it's own Metadata and table
definitions. Each metadata is tied to a different schema. 

Since each service manages its slice of the data independently, it was desirable to keep the alembic trees separate to
avoid cross-service dependencies in the revisions, and to have the revisions pertaining to a particular service with the 
code for that service.

# Challenges encountered
Alembic by default has some interesting issues with autogenerating revisions within schemas. It tended to try to
re-create the whole table instead of adding/removing single elements. Adding the options to `env.py` to include schemas
allowed alembic to recognize changes to schemas, but it had the side effect of making the autogenerated revision see 
*all* schemas, even those for the other services. This resulted in the autogenerated revision for one service attempting
to delete all tables of a different service. Fortunately alembic supports an `include_object`, which allows for more
granular and programmatic control of what the autogeneration process decides to do with particular entities. In this 
case I added a case to the `include_object` to check the target schema if the item under consideration.

The second challenge was managing the alembic tree. Under the hood alembic keeps track of the DB version in the 
`alembic_version` table. In a simple flow this table contains a single value as there is only one revision head. An
alternate flow requires multiple heads, one per service. In the case of multiple heads, this table can contain more than
one value, one per revision head. Multiple heads in this manner were proving somewhat problematic
when generating revisions as it was often unclear what the appropriate `down_revision` should be, nor did alembic
consistently pick the correct one, nor did it allow the user to manually specify it in the command to generate the
revision. It also required each alembic setup to be aware of the Metadata of all the other services. In short, it created
some rather odd cross-service dependencies that lead to unexpected behavior. This could also be due to unfamiliarity with
the expected usages of multiple bases (https://alembic.sqlalchemy.org/en/latest/branches.html#working-with-multiple-bases)

However, in order to allow the `alembic_version` table to have multiple values, alembic needs to be aware of all revisions+heads,
meaning that everything would need to managed together as separate heads. However, it was just concluded that this was 
not all that desirable. Managing each service separately was problematic because the default is for all of them to use
the same `alembic_version` table, which is not technically possible. However, it turns out that alembic supports multiple
`alembic_version` tables, but in different schemas.

# How this pattern works
Each service has its own alembic setup. Each alembic setup is only aware of the DB metadata that pertains to one service.
Each DB metadata is tied to a separate schema. Each alembic instance has its own alembic configuration, and is interacted
with as if the services were not co-located in the same DB. Each service tracks its DB version in a separate 
`alembic_version` table. In this way, the fact that the data is in the same DB is an incidental artifact of the 
configuration. 

# What did I add to alembic to get this to work?
1. Tell alembic to look at all schemas when autogenerating the revisions (`include_schemas=True`)
2. Tell alembic to place the `alembic_version` table within the schema tied to the DB metadata (`version_table_schema=target_metadata.schema`)
3. Have the `include_object` check the schema of objects when making decisions 
(`elif typ == 'table' and obj.schema != target_metadata.schema`). Yes, this just includes tables, an extension to 
include indices will likely be needed.

# Pros/Cons
* Pro: Revisions are cleanly isolated by service. 
* Pro: Updating one service does not require updating other services.
* Cons: Isolation depends on correct setup of alembic `env.py` and DB metadata. It would only take one rogue alembic 
setup to potentially delete all tables for all other services. 